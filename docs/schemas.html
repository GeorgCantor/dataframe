<!DOCTYPE html SYSTEM "about:legacy-compat"><html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex">  <meta name="built-on" content="2023-01-31T12:59:45.126535737"/><meta name="build-number" content="452"/>    <meta name="keywords" content="">   <script> (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start': new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0], j=d.createElement(s),dl=l!='dataLayer'?'&amp;l='+l:'';j.async=true;j.src= '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-5P98'); </script><script src="https://resources.jetbrains.com/storage/help-app/v5/analytics.js"></script>  <title>Working with Data Schemas | Dataframe Documentation</title><script id="virtual-toc-data" type="application/json">[{"id":"dataschema-workflow-in-jupyter","level":0,"title":"DataSchema workflow in Jupyter","anchor":"#dataschema-workflow-in-jupyter"},{"id":"schema-inheritance","level":0,"title":"Schema inheritance","anchor":"#schema-inheritance"},{"id":"custom-data-schemas","level":0,"title":"Custom data schemas","anchor":"#custom-data-schemas"},{"id":"use-external-data-schemas-in-jupyter","level":0,"title":"Use external data schemas in Jupyter","anchor":"#use-external-data-schemas-in-jupyter"},{"id":"import-data-schemas-e-g-from-openapi-in-jupyter","level":0,"title":"Import Data Schemas, e.g. from OpenAPI, in Jupyter","anchor":"#import-data-schemas-e-g-from-openapi-in-jupyter"}]</script>   <link href="https://resources.jetbrains.com/storage/help-app/v5/app.css" rel="stylesheet"/>   <link rel="icon" href="https://resources.jetbrains.com/storage/products/jetbrains/img/icons/favicon.ico" sizes="any"/><!-- 32×32 --><link rel="icon" href="https://resources.jetbrains.com/storage/products/jetbrains/img/icons/icon.svg" type="image/svg+xml"/><link rel="apple-touch-icon" href="https://resources.jetbrains.com/storage/products/jetbrains/img/icons/apple-touch-icon.png"/><!-- 180×180 --><link rel="manifest" href="https://www.jetbrains.com/site.webmanifest"/><meta name="apple-mobile-web-app-title" content="JetBrains"/><meta name="application-name" content="JetBrains"/><meta name="msapplication-TileColor" content="#000000"/><meta name="theme-color" content="#000000"/>  <meta name="image" content=""/><!-- Open Graph --><meta property="og:title" content="Working with Data Schemas | Dataframe"/><meta property="og:description" content=""/><meta property="og:image" content=""/><meta property="og:site_name" content="Dataframe Help"/><meta property="og:type" content="website"/><meta property="og:locale" content="en_US"/><meta property="og:url" content="https://kotlin.github.io/dataframe/0.9/schemas.html"/><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content=""/><meta name="twitter:title" content="Working with Data Schemas | Dataframe"/><meta name="twitter:description" content=""/><meta name="twitter:creator" content=""/><meta name="twitter:image:src" content=""/><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json"> { "@context": "http://schema.org", "@type": "WebPage", "@id": "https://kotlin.github.io/dataframe/0.9/schemas.html#webpage", "url": "https://kotlin.github.io/dataframe/0.9/schemas.html", "name": "Working with Data Schemas | Dataframe", "description": "", "image": "", "inLanguage":"en-US" }</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json"> { "@type": "WebSite", "@id": "https://kotlin.github.io/dataframe/#website", "url": "https://kotlin.github.io/dataframe/", "name": "Dataframe Help" }</script><!-- End Schema.org --></head>    <body data-id="schemas" data-main-title="Working with Data Schemas" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}"  data-template="article"  data-breadcrumbs="overview.md|Overview"  >  <div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Dataframe 0.9 Help</h3><div class="shortcuts-switcher"><label for="switch-shortcuts">Keymap:</label><select class="select _shortcuts" height="1" id="switch-shortcuts">  </select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="schemas" id="schemas.md"  >Working with Data Schemas</h1><p id="da5dff37" ><code class="code "   >Kotlin Dataframe</code> provides typed data access via <a href="extensionpropertiesapi.html" id="8476c388"   >generation of extension properties</a> for type <code class="code "   >DataFrame&lt;T&gt;</code>, where <code class="code "   >T</code> is a marker class that represents <code class="code "   >DataSchema</code> of <code class="code "   >DataFrame</code>.</p><p id="ca4b3699" >Schema of <code class="code "   >DataFrame</code> is a mapping from column names to column types of <code class="code "   >DataFrame</code>. It ignores order of columns in <code class="code "   >DataFrame</code>, but tracks column hierarchy.</p><p id="e32fe1b7" >In Jupyter environment compile-time <code class="code "   >DataFrame</code> schema is synchronized with real-time data after every cell execution.</p><p id="c80003cc" >In IDEA projects you can use <a href="installation.html#data-schema-preprocessor" id="9198a9c"   >gradle plugin</a> to extract schema from dataset and generate extension properties.</p><section class="chapter"  ><h2 id="dataschema-workflow-in-jupyter" data-toc="dataschema-workflow-in-jupyter"  >DataSchema workflow in Jupyter</h2><p id="6871fabc" >After execution of cell</p><div class="code-block" data-lang="kotlin"      data-anchors="[c0607df7]"     >val df = dataFrameOf(&quot;name&quot;, &quot;age&quot;)(
    &quot;Alice&quot;, 15,
    &quot;Bob&quot;, null
)
</div><p id="4608e3cd" >the following actions take place:</p><ol class="list _decimal" id="caae3d9a"  type="1"  ><li class="list__item" id="1eb573f9" ><p>Columns in <code class="code "   >df</code> are analyzed to extract data schema</p></li><li class="list__item" id="f4aa072d" ><p>Empty interface with <code class="code "   >DataSchema</code> annotation is generated:</p></li></ol><div class="code-block" data-lang="kotlin"      data-anchors="[3b899c20]"     >@DataSchema
interface DataFrameType
</div><ol class="list _decimal" id="73e6373c"  type="1"  start="3"><li class="list__item" id="ec7f2e4c" ><p>Extension properties for this <code class="code "   >DataSchema</code> are generated:</p></li></ol><div class="code-block" data-lang="kotlin"      data-anchors="[29b19c0a]"     >val ColumnsContainer&lt;DataFrameType&gt;.age: DataColumn&lt;Int?&gt; @JvmName(&quot;DataFrameType_age&quot;) get() = this[&quot;age&quot;] as DataColumn&lt;Int?&gt;
val DataRow&lt;DataFrameType&gt;.age: Int? @JvmName(&quot;DataFrameType_age&quot;) get() = this[&quot;age&quot;] as Int?
val ColumnsContainer&lt;DataFrameType&gt;.name: DataColumn&lt;String&gt; @JvmName(&quot;DataFrameType_name&quot;) get() = this[&quot;name&quot;] as DataColumn&lt;String&gt;
val DataRow&lt;DataFrameType&gt;.name: String @JvmName(&quot;DataFrameType_name&quot;) get() = this[&quot;name&quot;] as String
</div><p id="53cce8bb" >Every column produces two extension properties:</p><ul class="list _bullet" id="6985fce9"    ><li class="list__item" id="535bf7f4" ><p>Property for <code class="code "   >ColumnsContainer&lt;DataFrameType&gt;</code> returns column</p></li><li class="list__item" id="ff569cd2" ><p>Property for <code class="code "   >DataRow&lt;DataFrameType&gt;</code> returns cell value</p></li></ul><ol class="list _decimal" id="348eeb0e"  type="1"  start="4"><li class="list__item" id="b9b2698a" ><p><code class="code "   >df</code> variable is typed by schema interface:</p></li></ol><div class="code-block" data-lang="kotlin"      data-anchors="[e8a08483]"     >val temp = df
</div><div class="code-block" data-lang="kotlin"      data-anchors="[6b57a0e1]"     >val df = temp.cast&lt;DataFrameType&gt;()
</div><aside data-type="tip" class="prompt" data-title="" id="1a3b62e8" ><p id="688dfa2" >_Note, that object instance after casting remains the same. See <a href="cast.html" id="31d6f5d9"   >cast</a>.</p></aside><p id="69998334" >To log all these additional code executions, use cell magic</p><p> <code class="code "   >%trackExecution -all</code></p></section><section class="chapter"  ><h2 id="schema-inheritance" data-toc="schema-inheritance"  >Schema inheritance</h2><p id="34397ab9" >In order to reduce amount of generated code, previously generated <code class="code "   >DataSchema</code> interfaces are reused and only new properties are introduced</p><p id="b078e33a" >Let's filter out all <code class="code "   >null</code> values from <code class="code "   >age</code> column and add one more column of type <code class="code "   >Boolean</code>:</p><div class="code-block" data-lang="kotlin"      data-anchors="[6837770]"     >val filtered = df.filter { age != null }.add(&quot;isAdult&quot;) { age!! &gt; 18 }
</div><p id="cbb813a9" >New schema interface for <code class="code "   >filtered</code> variable will be derived from previously generated <code class="code "   >DataFrameType</code>:</p><div class="code-block" data-lang="kotlin"      data-anchors="[438262a9]"     >@DataSchema
interface DataFrameType1 : DataFrameType
</div><p id="5c9a2b88" >Extension properties for data access are generated only for new and overriden members of <code class="code "   >DataFrameType1</code> interface:</p><div class="code-block" data-lang="kotlin"      data-anchors="[10807c2a]"     >val ColumnsContainer&lt;DataFrameType1&gt;.age: DataColumn&lt;Int&gt; get() = this[&quot;age&quot;] as DataColumn&lt;Int&gt;
val DataRow&lt;DataFrameType1&gt;.age: Int get() = this[&quot;age&quot;] as Int
val ColumnsContainer&lt;DataFrameType1&gt;.isAdult: DataColumn&lt;Boolean&gt; get() = this[&quot;isAdult&quot;] as DataColumn&lt;Boolean&gt;
val DataRow&lt;DataFrameType1&gt;.isAdult: String get() = this[&quot;isAdult&quot;] as Boolean
</div><p id="4d7d1866" >Then variable <code class="code "   >filtered</code> is cast to new interface:</p><div class="code-block" data-lang="kotlin"      data-anchors="[4185947c]"     >val temp = filtered
</div><div class="code-block" data-lang="kotlin"      data-anchors="[8bd1aa8e]"     >val filtered = temp.cast&lt;DataFrameType1&gt;()
</div></section><section class="chapter"  ><h2 id="custom-data-schemas" data-toc="custom-data-schemas"  >Custom data schemas</h2><p id="4315b26b" >You can define your own <code class="code "   >DataSchema</code> interfaces and use them in functions and classes to represent <code class="code "   >DataFrame</code> with specific set of columns:</p><div class="code-block" data-lang="kotlin"      data-anchors="[210e94e6]"     >@DataSchema
interface Person {
    val name: String
    val age: Int
}
</div><p id="10dc8b8e" >After execution of this cell in Jupyter or annotation processing in IDEA, extension properties for data access will be generated. Now we can use these properties to create functions for typed <code class="code "   >DataFrame</code>:</p><div class="code-block" data-lang="kotlin"      data-anchors="[c82e2478]"     >fun DataFrame&lt;Person&gt;.splitName() = split { name }.by(&quot;,&quot;).into(&quot;firstName&quot;, &quot;lastName&quot;)
fun DataFrame&lt;Person&gt;.adults() = filter { age &gt; 18 }
</div><p id="5bc6fc1b" >In Jupyter these functions will work automatically for any <code class="code "   >DataFrame</code> that matches <code class="code "   >Person</code> schema:</p><div class="code-block" data-lang="kotlin"      data-anchors="[8a9620a0]"     >val df = dataFrameOf(&quot;name&quot;, &quot;age&quot;, &quot;weight&quot;)(
    &quot;Merton, Alice&quot;, 15, 60.0,
    &quot;Marley, Bob&quot;, 20, 73.5
)
</div><p id="8f204c41" >Schema of <code class="code "   >df</code> is compatible with <code class="code "   >Person</code>, so auto-generated schema interface will inherit from it:</p><div class="code-block" data-lang="kotlin"      data-anchors="[537e41ba]"     >@DataSchema(isOpen = false)
interface DataFrameType : Person

val ColumnsContainer&lt;DataFrameType&gt;.weight: DataColumn&lt;Double&gt; get() = this[&quot;weight&quot;] as DataColumn&lt;Double&gt;
val DataRow&lt;DataFrameType&gt;.weight: Double get() = this[&quot;weight&quot;] as Double
</div><p id="a8b7fcf8" >Despite <code class="code "   >df</code> has additional column <code class="code "   >weight</code>, previously defined functions for <code class="code "   >DataFrame&lt;Person&gt;</code> will work for it:</p><div class="code-block" data-lang="kotlin"      data-anchors="[40a11414]"     >df.splitName()
</div><div class="code-block" data-lang="plaintext"      data-anchors="[364a9d75]"     >firstName lastName age weight
   Merton    Alice  15 60.000
   Marley      Bob  20 73.125
</div><div class="code-block" data-lang="kotlin"      data-anchors="[24ff9ef1]"     >df.adults()
</div><div class="code-block" data-lang="plaintext"      data-anchors="[323dabfa]"     >name        age weight
Marley, Bob  20   73.5
</div><p id="6ce4ae80" >In JVM project you will have to <a href="cast.html" id="1fd9be38"   >cast</a> <code class="code "   >DataFrame</code> explicitly to the target interface:</p><div class="code-block" data-lang="kotlin"      data-anchors="[f561f142]"     >df.cast&lt;Person&gt;().splitName()
</div></section><section class="chapter"  ><h2 id="use-external-data-schemas-in-jupyter" data-toc="use-external-data-schemas-in-jupyter"  >Use external data schemas in Jupyter</h2><p id="307b35f" >Sometimes it is convenient to extract reusable code from Jupyter notebook into Kotlin JVM library. If this code uses <a href="#custom-data-schemas" id="6718b9c7"   >Custom data schemas</a>, schema interfaces should also be extracted. In order to enable support them in Jupyter, you should register them in library <a href="https://github.com/Kotlin/kotlin-jupyter/blob/master/docs/libraries.md" id="c3b97f32"   data-external="true" rel="noopener noreferrer" >integration class</a> with <code class="code "   >useSchema</code> function:</p><div class="code-block" data-lang="kotlin"      data-anchors="[15961573]"     >@DataSchema
interface Person {
    val name: String
    val age: Int
}

fun DataFrame&lt;Person&gt;.countAdults() = count { it[Person::age] &gt; 18 }

@JupyterLibrary
internal class Integration : JupyterIntegration() {

    override fun Builder.onLoaded() {
        onLoaded {
            useSchema&lt;Person&gt;()
        }
    }
}
</div><p id="ffa4c2bf" >After loading this library into Jupyter notebook, schema interfaces for all <code class="code "   >DataFrame</code> variables that match <code class="code "   >Person</code> schema will derive from <code class="code "   >Person</code></p><div class="code-block" data-lang="kotlin"      data-anchors="[c46bc071]"     >val df = dataFrameOf(&quot;name&quot;, &quot;age&quot;)(
    &quot;Alice&quot;, 15,
    &quot;Bob&quot;, 20
)
</div><p id="3810d76c" >Now <code class="code "   >df</code> is assignable to <code class="code "   >DataFrame&lt;Person&gt;</code> and <code class="code "   >countAdults</code> is available:</p><div class="code-block" data-lang="kotlin"      data-anchors="[b9c8623c]"     >df.countAdults()
</div></section><section class="chapter"  ><h2 id="import-data-schemas-e-g-from-openapi-in-jupyter" data-toc="import-data-schemas-e-g-from-openapi-in-jupyter"  >Import Data Schemas, e.g. from OpenAPI, in Jupyter</h2><p id="d471a76d" >Similar to <a href="gradle.html#openapi-schemas" id="19e9d104"   >importing OpenAPI data schemas in Gradle projects</a>, you can also do this in Jupyter notebooks. There is only a slight difference in notation:</p><p id="5e41608f" >Import the schema using any path (<code class="code "   >String</code>), <code class="code "   >URL</code>, or <code class="code "   >File</code>:</p><div class="code-block" data-lang="kotlin"      data-anchors="[f3e86e1c]"     >val PetStore = importDataSchema(&quot;https://petstore3.swagger.io/api/v3/openapi.json&quot;)
</div><p id="4d257188" >and then from next cell you run and onwards, you can call, for example:</p><div class="code-block" data-lang="kotlin"      data-anchors="[f7322592]"     >val df = PetStore.Pet.readJson(&quot;https://petstore3.swagger.io/api/v3/pet/findByStatus?status=available&quot;)
</div><p id="c2fb5b90" >So, very similar indeed!</p><p id="4b6d7510" >(Note: The type of <code class="code "   >PetStore</code> will be generated as <code class="code "   >PetStoreDataSchema</code>, but this doesn't affect the way you can use it.)</p></section><div class="last-modified"> Last modified: 31 January 2023</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom">   <a class="navigation-links__prev" href="hierarchical.html">Hierarchical data structures</a>   <a class="navigation-links__next" href="gradle.html">Data Schemas in Gradle projects</a>   </div></article>  </div></section></main></div>  <script src="https://resources.jetbrains.com/storage/help-app/v5/app.js"></script>  </body></html>