<!DOCTYPE html SYSTEM "about:legacy-compat"><html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex">  <meta name="built-on" content="2023-02-06T18:18:58.548891649"/><meta name="build-number" content="455"/>    <meta name="keywords" content="">   <script> (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start': new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0], j=d.createElement(s),dl=l!='dataLayer'?'&amp;l='+l:'';j.async=true;j.src= '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-5P98'); </script><script src="https://resources.jetbrains.com/storage/help-app/v5/analytics.js"></script>  <title>Read | Dataframe Documentation</title><script id="virtual-toc-data" type="application/json">[{"id":"reading-csv","level":0,"title":"Reading CSV","anchor":"#reading-csv"},{"id":"dealing-with-locale-specific-numbers","level":1,"title":"Dealing with locale specific numbers","anchor":"#dealing-with-locale-specific-numbers"},{"id":"reading-json","level":0,"title":"Reading JSON","anchor":"#reading-json"},{"id":"json-reading-options-type-clash-tactic","level":1,"title":"JSON Reading Options: Type Clash Tactic","anchor":"#json-reading-options-type-clash-tactic"},{"id":"json-reading-options-key-value-paths","level":1,"title":"JSON Reading Options: Key/Value Paths","anchor":"#json-reading-options-key-value-paths"},{"id":"reading-excel","level":0,"title":"Reading Excel","anchor":"#reading-excel"},{"id":"reading-apache-arrow-formats","level":0,"title":"Reading Apache Arrow formats","anchor":"#reading-apache-arrow-formats"}]</script>   <link href="https://resources.jetbrains.com/storage/help-app/v5/app.css" rel="stylesheet"/>   <link rel="icon" href="https://resources.jetbrains.com/storage/products/jetbrains/img/icons/favicon.ico" sizes="any"/><!-- 32×32 --><link rel="icon" href="https://resources.jetbrains.com/storage/products/jetbrains/img/icons/icon.svg" type="image/svg+xml"/><link rel="apple-touch-icon" href="https://resources.jetbrains.com/storage/products/jetbrains/img/icons/apple-touch-icon.png"/><!-- 180×180 --><link rel="manifest" href="https://www.jetbrains.com/site.webmanifest"/><meta name="apple-mobile-web-app-title" content="JetBrains"/><meta name="application-name" content="JetBrains"/><meta name="msapplication-TileColor" content="#000000"/><meta name="theme-color" content="#000000"/>  <meta name="image" content=""/><!-- Open Graph --><meta property="og:title" content="Read | Dataframe"/><meta property="og:description" content=""/><meta property="og:image" content=""/><meta property="og:site_name" content="Dataframe Help"/><meta property="og:type" content="website"/><meta property="og:locale" content="en_US"/><meta property="og:url" content="https://kotlin.github.io/dataframe/0.9/read.html"/><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content=""/><meta name="twitter:title" content="Read | Dataframe"/><meta name="twitter:description" content=""/><meta name="twitter:creator" content=""/><meta name="twitter:image:src" content=""/><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json"> { "@context": "http://schema.org", "@type": "WebPage", "@id": "https://kotlin.github.io/dataframe/0.9/read.html#webpage", "url": "https://kotlin.github.io/dataframe/0.9/read.html", "name": "Read | Dataframe", "description": "", "image": "", "inLanguage":"en-US" }</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json"> { "@type": "WebSite", "@id": "https://kotlin.github.io/dataframe/#website", "url": "https://kotlin.github.io/dataframe/", "name": "Dataframe Help" }</script><!-- End Schema.org --></head>    <body data-id="read" data-main-title="Read" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}"  data-template="article"  data-breadcrumbs="Operations///io.md|Input/output"  >  <div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Dataframe 0.9 Help</h3><div class="shortcuts-switcher"><label for="switch-shortcuts">Keymap:</label><select class="select _shortcuts" height="1" id="switch-shortcuts">  </select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="read" id="read.md"  >Read</h1><p id="c06e6a16" ><code class="code "   >DataFrame</code> supports CSV, TSV, JSON, XLS and XLSX, Apache Arrow input formats.</p><p id="675c561f" ><code class="code "   >read</code> method automatically detects input format based on file extension and content</p><div class="code-block" data-lang="kotlin"      data-anchors="[5ad192f3]"     >DataFrame.read(&quot;input.csv&quot;)
</div><p id="b345f7ad" >Input string can be a file path or URL.</p><section class="chapter"  ><h2 id="reading-csv" data-toc="reading-csv"  >Reading CSV</h2><p id="ed7f95ae" >All these calls are valid:</p><div class="code-block" data-lang="kotlin"      data-anchors="[a971d2b7]"     >import java.io.File
import java.net.URL

DataFrame.readCSV(&quot;input.csv&quot;)
DataFrame.readCSV(File(&quot;input.csv&quot;))
DataFrame.readCSV(URL(&quot;https://raw.githubusercontent.com/Kotlin/dataframe/master/data/jetbrains_repositories.csv&quot;))
</div><p id="6aa86f39" >All <code class="code "   >readCSV</code> overloads support different options. For example, you can specify custom delimiter if it differs from <code class="code "   >,</code>, charset and column names if your CSV is missing them</p><div class="code-block" data-lang="kotlin"      data-anchors="[883f92d4]"     >val df = DataFrame.readCSV(
    file,
    delimiter = '|',
    header = listOf(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;),
    parserOptions = ParserOptions(nullStrings = setOf(&quot;not assigned&quot;))
)
</div><p id="837fcea7" >Column types will be inferred from the actual CSV data. Suppose that CSV from the previous example had the following content:</p><div class="table-wrapper"><table class=" wide" id="573bfaed" ><thead><tr class="ijRowHead" id="ba1e8dcb" ><th id="7a070604"    ><p>A</p></th><th id="4518c81a"    ><p>B</p></th><th id="55c1528a"    ><p>C</p></th><th id="cdfafc77"    ><p>D</p></th></tr></thead><tbody><tr class="" id="d3f4dcab" ><td id="7c5d2355"    ><p>12</p></td><td id="a6f40ff2"    ><p>tuv</p></td><td id="bbdcf2e6"    ><p>0.12</p></td><td id="6c94198d"    ><p>true</p></td></tr><tr class="" id="508a1b04" ><td id="79bb838e"    ><p>41</p></td><td id="bf1daf63"    ><p>xyz</p></td><td id="cfbc4ea4"    ><p>3.6</p></td><td id="55b6bafd"    ><p>not assigned</p></td></tr><tr class="" id="7bf5cf1d" ><td id="c830f5e2"    ><p>89</p></td><td id="1a665333"    ><p>abc</p></td><td id="746b5ec9"    ><p>7.1</p></td><td id="ab535bec"    ><p>false</p></td></tr></tbody></table></div><p id="a6391c1f" >Dataframe schema we get is:</p><div class="code-block" data-lang="plaintext"      data-anchors="[1acdc71b]"     >A: Int
B: String
C: Double
D: Boolean?
</div><p id="9d541463" >DataFrame will try to parse columns as JSON, so when reading following table with JSON object in column D:</p><div class="table-wrapper"><table class=" wide" id="21b70043" ><thead><tr class="ijRowHead" id="8c8d3407" ><th id="80d6f76c"    ><p>A</p></th><th id="6fe73f"    ><p>D</p></th></tr></thead><tbody><tr class="" id="b16e8822" ><td id="7f8cf857"    ><p>12</p></td><td id="fa15f83e"    ><p>{&quot;B&quot;:2,&quot;C&quot;:3}</p></td></tr><tr class="" id="4bb578d" ><td id="6a9e952d"    ><p>41</p></td><td id="1bb45f83"    ><p>{&quot;B&quot;:3,&quot;C&quot;:2}</p></td></tr></tbody></table></div><p id="ad4d07c2" >We get this data schema where D is ColumnGroup with 2 children columns:</p><div class="code-block" data-lang="plaintext"      data-anchors="[187481be]"     >A: Int
D:
    B: Int
    C: Int
</div><p id="697809e4" >For column where values are lists of JSON values:</p><div class="table-wrapper"><table class=" wide" id="4c9af8d8" ><thead><tr class="ijRowHead" id="a8058e93" ><th id="f6fbba47"    ><p>A</p></th><th id="f37c7416"    ><p>G</p></th></tr></thead><tbody><tr class="" id="f5a977e4" ><td id="7485151"    ><p>12</p></td><td id="883ba1a4"    ><p>[{&quot;B&quot;:1,&quot;C&quot;:2,&quot;D&quot;:3},{&quot;B&quot;:1,&quot;C&quot;:3,&quot;D&quot;:2}]</p></td></tr><tr class="" id="47a2a97" ><td id="f6121215"    ><p>41</p></td><td id="57aea770"    ><p>[{&quot;B&quot;:2,&quot;C&quot;:1,&quot;D&quot;:3}]</p></td></tr></tbody></table></div><div class="code-block" data-lang="plaintext"      data-anchors="[a2aff49f]"     >A: Int
G: *
    B: Int
    C: Int
    D: Int
</div><section class="chapter"  ><h3 id="dealing-with-locale-specific-numbers" data-toc="dealing-with-locale-specific-numbers"  >Dealing with locale specific numbers</h3><p id="1401230" >Sometimes columns in your CSV can be interpreted differently depending on your system locale.</p><div class="table-wrapper"><table class="" id="eb3e929f" ><thead><tr class="ijRowHead" id="524fcb4d" ><th id="dcd29cd1"    ><p>numbers</p></th></tr></thead><tbody><tr class="" id="91943dd6" ><td id="5ab148a3"    ><p>12,123</p></td></tr><tr class="" id="88aa9782" ><td id="212ac569"    ><p>41,111</p></td></tr></tbody></table></div><p id="53f7de1f" >Here comma can be decimal or thousands separator, thus different values. You can deal with it in two ways</p><ol class="list _decimal" id="9c84338d"  type="1"  ><li class="list__item" id="22dd457a" ><p>Provide locale as a parser option</p></li></ol><div class="code-block" data-lang="kotlin"      data-anchors="[c9b1f82b]"     >val df = DataFrame.readCSV(
    file,
    parserOptions = ParserOptions(locale = Locale.UK),
)
</div><ol class="list _decimal" id="977633f1"  type="1"  start="2"><li class="list__item" id="bc8411bd" ><p>Disable type inference for specific column and convert it yourself</p></li></ol><div class="code-block" data-lang="kotlin"      data-anchors="[be820147]"     >val df = DataFrame.readCSV(
    file,
    colTypes = mapOf(&quot;colName&quot; to ColType.String)
)
</div></section></section><section class="chapter"  ><h2 id="reading-json" data-toc="reading-json"  >Reading JSON</h2><p id="cfff86bb" >Basics for reading JSONs are the same: you can read from file or from remote URL.</p><div class="code-block" data-lang="kotlin"      data-anchors="[e1637a7c]"     >DataFrame.readJson(&quot;https://covid.ourworldindata.org/data/owid-covid-data.json&quot;)
</div><p id="379b3569" >Note that after reading a JSON with a complex structure, you can get hierarchical dataframe: dataframe with <code class="code "   >ColumnGroup</code>s and <code class="code "   >FrameColumn</code>s.</p><p id="49cbfc69" >Also note that type inferring process for JSON is much simpler than for CSV. JSON string literals are always supposed to have String type, number literals take different <code class="code "   >Number</code> kinds, boolean literals are converted to <code class="code "   >Boolean</code>.</p><p id="a658d272" >Let's take a look at the following JSON:</p><div class="code-block" data-lang="json"      data-anchors="[a8a2c853]"     >[
    {
        &quot;A&quot;: &quot;1&quot;,
        &quot;B&quot;: 1,
        &quot;C&quot;: 1.0,
        &quot;D&quot;: true
    },
    {
        &quot;A&quot;: &quot;2&quot;,
        &quot;B&quot;: 2,
        &quot;C&quot;: 1.1,
        &quot;D&quot;: null
    },
    {
        &quot;A&quot;: &quot;3&quot;,
        &quot;B&quot;: 3,
        &quot;C&quot;: 1,
        &quot;D&quot;: false
    },
    {
        &quot;A&quot;: &quot;4&quot;,
        &quot;B&quot;: 4,
        &quot;C&quot;: 1.3,
        &quot;D&quot;: true
    }
]
</div><p id="8bab4253" >We can read it from file</p><div class="code-block" data-lang="kotlin"      data-anchors="[31b2fb63]"     >val df = DataFrame.readJson(file)
</div><p id="d5f3090f" >Corresponding dataframe schema will be</p><div class="code-block" data-lang="plaintext"      data-anchors="[dac2b876]"     >A: String
B: Int
C: Number
D: Boolean?
</div><p id="839d96b0" >Column A has <code class="code "   >String</code> type because all values are string literals, no implicit conversion is performed. Column C has <code class="code "   >Number</code> type because it's the least common type for <code class="code "   >Int</code> and <code class="code "   >Double</code>.</p><section class="chapter"  ><h3 id="json-reading-options-type-clash-tactic" data-toc="json-reading-options-type-clash-tactic"  >JSON Reading Options: Type Clash Tactic</h3><p id="6b98940e" >By default, if a type clash occurs when reading JSON, a new column group is created consisting of: &quot;value&quot;, &quot;array&quot;, and any number of object properties:</p><p id="dee343f6" >&quot;value&quot; will be set to the value of the JSON element if it's a primitive, else it will be <code class="code "   >null</code>.<br/> &quot;array&quot; will be set to the array of values if the json element is an array, else it will be <code class="code "   >[]</code>.<br/> If the json element is an object, then each property will spread out to its own column in the group, else these columns will be <code class="code "   >null</code>.</p><p id="4d8df5c7" >In this case <code class="code "   >typeClashTactic = JSON.TypeClashTactic.ARRAY_AND_VALUE_COLUMNS</code>.</p><p id="5836f2c7" >For example:</p><div class="code-block" data-lang="json"      data-anchors="[263167aa]"     >[
    { &quot;a&quot;: &quot;text&quot; },
    { &quot;a&quot;: { &quot;b&quot;: 2 } },
    { &quot;a&quot;: [ 6, 7, 8 ] }
]
</div><p id="37f3da90" >will be read like (including <code class="code "   >null</code> and <code class="code "   >[]</code> values):</p><div class="code-block" data-lang="plaintext"      data-anchors="[2763ea82]"     >⌌----------------------------------------------⌍
|  | a:{b:Int?, value:String?, array:List&lt;Int&gt;}|
|--|-------------------------------------------|
| 0|   {b:null, value:&quot;text&quot;,  array:[]       }|
| 1|   {b:2,    value:null,    array:[]       }|
| 2|   {b:null, value:null,    array:[6, 7, 8]}|
⌎----------------------------------------------⌏
</div><p id="87641a05" >This makes it more convenient to work with the data, but it can be confusing if you're not expecting it or if you just need the type to be an <code class="code "   >Any</code>.</p><p id="856230fa" >For this case, you can set <code class="code "   >typeClashTactic = JSON.TypeClashTactic.ANY_COLUMNS</code> to get the following:</p><div class="code-block" data-lang="plaintext"      data-anchors="[2d630838]"     >⌌-------------⌍
|  |     a:Any|
|--|----------|
| 0|    &quot;text&quot;|
| 1|   { b:2 }|
| 2| [6, 7, 8]|
⌎-------------⌏
</div><p id="5c556614" >This option is also possible to set in the Gradle- and KSP plugin by providing <code class="code "   >jsonOptions</code>.</p></section><section class="chapter"  ><h3 id="json-reading-options-key-value-paths" data-toc="json-reading-options-key-value-paths"  >JSON Reading Options: Key/Value Paths</h3><p id="27399951" >If you have some JSON looking like</p><div class="code-block" data-lang="json"      data-anchors="[3cc725ba]"     >{
    &quot;dogs&quot;: {
        &quot;fido&quot;: {
            &quot;age&quot;: 3,
            &quot;breed&quot;: &quot;poodle&quot;
        },
        &quot;spot&quot;: {
            &quot;age&quot;: 5,
            &quot;breed&quot;: &quot;labrador&quot;
        },
        &quot;rex&quot;: {
            &quot;age&quot;: 2,
            &quot;breed&quot;: &quot;golden retriever&quot;
        },
        &quot;lucky&quot;: { ... },
        &quot;rover&quot;: { ... },
        &quot;max&quot;: { ... },
        &quot;buster&quot;: { ... },
        ...
    },
    &quot;cats&quot;: { ... }
}
</div><p id="baae58aa" >you will get a column for each dog, which becomes an issue when you have a lot of dogs. This issue is especially noticeable when generating data schemas from the JSON, as you might even run out of memory when doing that due to the sheer number of generated interfaces.<br/> Instead, you can use <code class="code "   >keyValuePaths</code> to specify paths to the objects that should be read as key value frame columns.</p><p id="92d1c13d" >This can be the difference between:</p><div class="code-block" data-lang="plaintext"      data-anchors="[f10dd7e8]"     >⌌---------------------------------------------------------------------------------------------------------------------------------------------...
|  |                      dogs:{fido:{age:Int, breed:String}, spot:{age:Int, breed:String}, rex:{age:Int, breed:String}, lucky:{age:Int, breed...
|--|------------------------------------------------------------------------------------------------------------------------------------------...
| 0| { fido:{ age:3, breed:poodle }, spot:{ age:5, breed:labrador }, rex:{ age:2, breed:golden retriever }, lucky:{ age:1, breed:poodle }, rov...
⌎---------------------------------------------------------------------------------------------------------------------------------------------...
</div><p id="cd6bf86e" >and</p><div class="code-block" data-lang="plaintext"      data-anchors="[8c615725]"     >⌌------------------------------------------------------------------------------------------------------⌍
|  | dogs:[key:String, value:{age:Int, breed:String}]| cats:[key:String, value:{age:Int, breed:String}]|
|--|-------------------------------------------------|-------------------------------------------------|
| 0|                                          [7 x 2]|                                          [6 x 2]|
⌎------------------------------------------------------------------------------------------------------⌏
</div><p id="39fd8f7a" >with dogs looking like</p><div class="code-block" data-lang="plaintext"      data-anchors="[183b235f]"     >⌌-------------------------------------------------⌍
|  | key:String|     value:{age:Int, breed:String}|
|--|-----------|----------------------------------|
| 0|       fido|           { age:3, breed:poodle }|
| 1|       spot|         { age:5, breed:labrador }|
| 2|        rex| { age:2, breed:golden retriever }|
| 3|      lucky|           { age:1, breed:poodle }|
| 4|      rover|         { age:3, breed:labrador }|
| 5|        max| { age:2, breed:golden retriever }|
| 6|     buster|           { age:1, breed:poodle }|
⌎-------------------------------------------------⌏
</div><p id="2a0ff800" >(The results are wrapped in a <code class="code "   >FrameColumn</code> instead of a <code class="code "   >ColumnGroup</code> since lengths between &quot;cats&quot; and &quot;dogs&quot; can vary, among other reasons.)</p><p id="7f43ba1d" >To specify the paths, you can use the <code class="code "   >JsonPath</code> class:</p><div class="code-block" data-lang="kotlin"      data-anchors="[3ed1d844]"     >DataFrame.readJsonStr(
    text = myJson,
    keyValuePaths = listOf(
        JsonPath().append(&quot;dogs&quot;), // which will result in '$[&quot;dogs&quot;]'
        JsonPath().append(&quot;cats&quot;), // which will result in '$[&quot;cats&quot;]'
    ),
)
</div><p id="bb0b403e" >Note: For the KSP plugin, the <code class="code "   >JsonPath</code> class is not available, so you will have to use the <code class="code "   >String</code> version of the paths instead. For example: <code class="code "   >jsonOptions = JsonOptions(keyValuePaths = [&quot;&quot;&quot;$&quot;&quot;&quot;, &quot;&quot;&quot;$[*][&quot;versions&quot;]&quot;&quot;&quot;])</code>. Only the bracket notation of json path is supported, as well as just double quotes, arrays, and wildcards.</p><p id="d7f6e8d9" >For more examples, see the &quot;examples/json&quot; module.</p></section></section><section class="chapter"  ><h2 id="reading-excel" data-toc="reading-excel"  >Reading Excel</h2><p id="1b76c7d3" >Add dependency:</p><div class="code-block" data-lang="kotlin"      data-anchors="[2e5c7110]"     >implementation(&quot;org.jetbrains.kotlinx:dataframe-excel:$dataframe_version&quot;)
</div><p id="c9a18e6" >Right now DataFrame supports reading Excel spreadsheet formats: xls, xlsx.</p><p id="b1dffbe0" >You can read from file or URL.</p><p id="fcd9ffcd" >Cells representing dates will be read as <code class="code "   >kotlinx.datetime.LocalDateTime</code>. Cells with number values, including whole numbers such as &quot;100&quot;, or calculated formulas will be read as <code class="code "   >Double</code></p><p id="50399548" >Sometimes cells can have wrong format in Excel file, for example you expect to read column of String:</p><div class="code-block" data-lang="plaintext"      data-anchors="[6f48e47d]"     >IDS
100 &lt;-- Intended to be String, but has wrong cell format in original .xlsx file
A100
B100
C100
</div><p id="ab172398" >You will get column of Serializable instead (common parent for Double &amp; String)</p><p id="73dee7b7" >You can fix it using convert:</p><div class="code-block" data-lang="kotlin"      data-anchors="[3fba59a2]"     >val df = dataFrameOf(&quot;IDS&quot;)(100.0, &quot;A100&quot;, &quot;B100&quot;, &quot;C100&quot;)
val df1 = df.convert(&quot;IDS&quot;).with(Infer.Type) {
    if (it is Double) {
        it.toLong().toString()
    } else {
        it
    }
}
df1[&quot;IDS&quot;].type() shouldBe typeOf&lt;String&gt;()
</div></section><section class="chapter"  ><h2 id="reading-apache-arrow-formats" data-toc="reading-apache-arrow-formats"  >Reading Apache Arrow formats</h2><p id="120f3e0e" >Add dependency:</p><div class="code-block" data-lang="kotlin"      data-anchors="[8b94c966]"     >implementation(&quot;org.jetbrains.kotlinx:dataframe-arrow:$dataframe_version&quot;)
</div><aside data-type="warning" class="prompt" data-title="" id="eb6f955"><p>Make sure to follow [Apache Arrow Java compatibility](https://arrow.apache.org/docs/java/install.html#java-compatibility) guide when using Java 9+</p></aside><p id="c13ab9c4" >Dataframe supports reading <a href="https://arrow.apache.org/docs/java/ipc.html#writing-and-reading-streaming-format" id="94f35263"   data-external="true" rel="noopener noreferrer" >Arrow interprocess streaming format</a> and <a href="https://arrow.apache.org/docs/java/ipc.html#writing-and-reading-random-access-files" id="e292f52b"   data-external="true" rel="noopener noreferrer" >Arrow random access format</a> from raw Channel (ReadableByteChannel for streaming and SeekableByteChannel for random access), InputStream, File or ByteArray.</p><div class="code-block" data-lang="kotlin"      data-anchors="[aa0f4058]"     >val df = DataFrame.readArrowFeather(file)
</div></section><div class="last-modified"> Last modified: 06 February 2023</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom">   <a class="navigation-links__prev" href="io.html">Input/output</a>   <a class="navigation-links__next" href="write.html">Write</a>   </div></article>  </div></section></main></div>  <script src="https://resources.jetbrains.com/storage/help-app/v5/app.js"></script>  </body></html>